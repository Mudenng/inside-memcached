# Memcached 源码分析 - 处理流程之请求到达预处理

当有某个客户端请求（如get/set/touch等）到达后，会唤醒对应的工作线程，工作线程调用event处理函数，即`event_handler()`，然后进入`drive_machine()`，之后这个客户端连接上的请求将不断转换状态，在自动机中被不同的阶段处理。请求到达后，线程首先需要对其进行分析和预处理，然后再分发到不同命令的处理过程。所以，要理解请求的整个处理流程，需要先看一下预处理和分发的过程。

##预处理过程

###初始状态
客户端连接在接收到新请求前的状态为`conn_new_cmd`，所以当有新请求到达后，首先会进入`drive_machine()`的`conn_new_cmd` case分支。

###防止饥饿
`conn_new_cmd`分支首先检查当前客户端的请求处理数目是否达到了上限，由于一个客户端可以同时发来很多请求，自动机将在循环中对这些请求逐一处理，但是如果不设置处理数目的限制，就有可能使线程长时间为某个客户端服务，而导致其他客户端产生饥饿状态，所以为了避免这种情况，线程都设置了一个请求数目的上限（默认reqs_pre_evnet = 20），如果达到了该上限，则先退出当前自动机循环，给其他客户端请求机会。当然，我们仅仅是退出了当前自动机，但不能放弃还没有处理的那些请求，我们需要在未来继续处理它们，所以这里的做法是在退出前线程主动触发一次event事件（事件的处理对象为当前客户端连接），该事件将会排到已经到达的其他客户端请求之后，所以当所有其他客户端请求处理完成后，这个线程会再次回来继续处理未完成的请求。

###状态转换

1. 如果请求数没有达到上限，可以被处理，则调用`reset_cmd_handler()`进行一些准备。该函数首先会尝试压缩一下当前连接的各缓冲区大小，以防止连续的get等命令造成缓冲区过大。然后根据目前输入缓冲区中是否有尚未被解析的数据来转换状态，如果还有尚未被解析的数据，则将状态切换为`conn_parse_cmd`，在这个状态下自动机的下次循环会进入到命令解析和处理分支；而如果输入缓冲中还没有尚未被解析的数据，则把状态转为`conn_waiting`。由于初始情况下，缓冲区中当然没有待处理数据，所以自然会进入到`conn_waiting`状态
2. 自动机在下一次循环中进入到`conn_waiting`分支，该状态的任务就是调用`update_event()`将连接上的当前event重新转换为未决状态，使得当前event能够再次触发回调函数。然后将状态转换为`conn_read`后退出自动机等待下一次event
3. 由于上一步的`update_event()`，还没有读取的请求数据会再次触发event事件，重新进入自动机，这次会进入`conn_read`分支。在该分支中，首先会根据协议类型，调用不同函数从socket中读取数据到输入缓冲`c->rbuf`中，如果读取成功，则设置自动机状态为`conn_parse_cmd`，否则重新回到`conn_waiting`状态或者出错退出
4. 读取成功后下次循环进入到`conn_parese_cmd`分支，该分支是所有类型命令的分发入口，在这里会调用`try_read_command()`来解析命令后交给不同的处理流程进行处理

##解析和分发
在`try_read_command()`函数中，会根据请求所使用的协议类型进行不同的处理，Memcached支持二进制协议和文本协议两种类型，由于文本协议更加便于我们理解，所以以下将使用文本协议进行分析。在文本协议处理的分支中，对读取到的一行数据进行检查后调用`process_command()`函数，该函数与二进制协议的`dispatch_bin_command()`函数对应，用来解析并分发请求。

###process_command
进入到`process_command()`函数后，首先调用`add_msghdr()`来为当前连接增加一个`msghdr`，该结构用来保存返回消息所需的缓冲区地址、长度、控制信息等。在`conn`结构体中，成员`msglist`指向由`msghdr`组成的数组，并由`msgsize`和`msgused`来分别指示数组大小和当前已使用大小，另外，每个`msghdr`中的数据缓冲区`msg_iov`也由`conn`统一管理，它们都指向`conn`中由`iovec`结构构成的数组`c->iov`中的一项。

接着，分析接收到的command，将其分解为tokens，分解其实就是将command字符串的空白符都替换成了'\0'，然后保存返回每一节子字符串的指针。最后根据命令的名称（token[0]）来调用不同的处理函数开始真正的请求处理过程。